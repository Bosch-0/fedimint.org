"use strict";(self.webpackChunkwiki_fedimint=self.webpackChunkwiki_fedimint||[]).push([[6600],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),h=c(n),p=a,f=h["".concat(l,".").concat(p)]||h[p]||u[p]||o;return n?i.createElement(f,s(s({ref:t},d),{},{components:n})):i.createElement(f,s({ref:t},d))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var c=2;c<o;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5061:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={sidebar_position:4},s="Minimint Wallet",r={unversionedId:"MiniMintDetails/Wallet",id:"MiniMintDetails/Wallet",title:"Minimint Wallet",description:"To be backed by Bitcoin the federation needs a federated on-chain wallet. It is used to receive deposits that clients",source:"@site/docs/MiniMintDetails/Wallet.md",sourceDirName:"MiniMintDetails",slug:"/MiniMintDetails/Wallet",permalink:"/wiki_fedimint/docs/MiniMintDetails/Wallet",draft:!1,editUrl:"https://github.com/humansinstitute/wiki_fedimint/tree/main/docs/MiniMintDetails/Wallet.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Minimint Consensus",permalink:"/wiki_fedimint/docs/MiniMintDetails/Consensus"},next:{title:"Frequently Asked Questions",permalink:"/wiki_fedimint/docs/category/frequently-asked-questions"}},l={},c=[{value:"Chain tip consensus",id:"chain-tip-consensus",level:2},{value:"Fee consensus",id:"fee-consensus",level:2},{value:"Randomness beacon",id:"randomness-beacon",level:2},{value:"Address Derivation",id:"address-derivation",level:2},{value:"Receiving Bitcoin",id:"receiving-bitcoin",level:2},{value:"Sending Bitcoin",id:"sending-bitcoin",level:2}],d={toc:c};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"minimint-wallet"},"Minimint Wallet"),(0,a.kt)("p",null,"To be backed by Bitcoin the federation needs a federated on-chain wallet. It is used to receive deposits that clients\nexchange for blind tokens and to make payouts when clients want to withdraw. Generally it is just a multisig wallet\ndefined by a script descriptor. For example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"wsh(sortedmulti(3,A,B,C,D))\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"A"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"B"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"C")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"D")," are the public keys of the federation members."),(0,a.kt)("p",null,"Yet, notable differences exist. Other than most wallets we do not require extended public keys since we define our own\nderivation scheme. Furthermore, the wallet can not rely on local fee estimation and the local chain tip since these\nmight be different for all members. Instead it uses the consensus algorithm to agree on these. Our particular protocol\nwill also use a randomness beacon."),(0,a.kt)("h2",{id:"chain-tip-consensus"},"Chain tip consensus"),(0,a.kt)("p",null,"To validate transactions a wallet needs to know the current chain tip. The problem with this is that different\nfederation members might see different chain tips either due to latency or even shallow forks."),(0,a.kt)("p",null,"To avoid the forking\nproblem we can just define that our internal chain tip is always e.g. 100 blocks behind the real one. This should\nsufficiently mitigate the risk of being on different forks (bitcoin itself would be in trouble with such deep forks).\nBut the latency problem remains."),(0,a.kt)("p",null,"To solve this we use the consensus, each round each participant does the following:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Query ",(0,a.kt)("inlineCode",{parentName:"li"},"bitcoind")," for the current block height"),(0,a.kt)("li",{parentName:"ol"},"If the block height shrank, use the previous one"),(0,a.kt)("li",{parentName:"ol"},"Propose ",(0,a.kt)("inlineCode",{parentName:"li"},"height - 100")," as the consensus height"),(0,a.kt)("li",{parentName:"ol"},"Receive peer proposals and use median as the new consensus height")),(0,a.kt)("p",null,"Due to the assumption that less than"),(0,a.kt)("p",null,"$$\\frac{1}{3}$$"),(0,a.kt)("p",null,"of the participants are malicious, this will always leads to a value that either was proposed by a honest participant or lies between two honest values to be chosen. Let's say that all"),(0,a.kt)("p",null,"$$f$$"),(0,a.kt)("p",null,"malicious proposals and"),(0,a.kt)("p",null,"$$n-2f$$"),(0,a.kt)("p",null,"honest proposals are accepted, then"),(0,a.kt)("p",null,"$$f < n-2f$$"),(0,a.kt)("p",null,"due to the previous requirement. It is easy to see that the"),(0,a.kt)("p",null,"$$f$$"),(0,a.kt)("p",null,"malicious proposals do not suffice to meaningfully alter the median."),(0,a.kt)("p",null,"Of course this assumes that all honest participants stay reasonable close to the real chain tip, but this is the task\nof the operators and outside our protocol."),(0,a.kt)("h2",{id:"fee-consensus"},"Fee consensus"),(0,a.kt)("p",null,"We also face a similar problem when spending Bitcoin. While the destinations and amounts are generally assumed to be\noutputs of the consensus protocol and thus unproblematic one factor of transactions is not easily made deterministic:\nthe fees. But to avoid depletion attacks by overpaying fees we need to agree on them."),(0,a.kt)("p",null,"Naively we could use an algorithm that uses on-chain analysis to determine proper fee levels. But we only agree on\na tip buried 100 blocks deep, which would make the algorithm quite unresponsive. Furthermore other algorithms that take\nthe mempool into account may be preferable, but agreeing on the mempool is a fools errand. Instead we use a modified\nversion of the algorithm used for the chain tip consensus. Each round each participant does the following:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Query ",(0,a.kt)("inlineCode",{parentName:"li"},"bitcoind")," for the current optimal fee rate"),(0,a.kt)("li",{parentName:"ol"},"Propose said rate as the consensus fee rate"),(0,a.kt)("li",{parentName:"ol"},"Receive peer proposals and use median as the new consensus height")),(0,a.kt)("p",null,"The median argument works similarly and we achieve a honest consensus on fee rates."),(0,a.kt)("h2",{id:"randomness-beacon"},"Randomness beacon"),(0,a.kt)("p",null,"In some cases it is useful to have access to agreed-upon, fair randomness. Thus every round every participant also\nproposes 32bytes of random data. The ones included in the consensus outcome are then XORed to form the round's\nrandomness beacon. We note that this is only safe if the items proposed to the consensus are encrypted till there is\nagreement on which contributions will be included. This is the case for HBBFT. Otherwise an attacker could wait for the\nother participants to announce their contribution and then adaptively chose his own to influence the outcome."),(0,a.kt)("h2",{id:"address-derivation"},"Address Derivation"),(0,a.kt)("p",null,'To allow clients to generate deposit addresses independent of the federation we do not use BIP32 derivation to\ngenerate new addresses from the wallet descriptor, but a custom derivation scheme. We instead use a pay-to-contract\nconstruction where a "contract" is hashed and added to all keys in the descriptor (added in the exponent in case of the\npub key). A descriptor with derived keys can then trivially be transformed into an address.'),(0,a.kt)("p",null,'In MiniMint the "contract" is just a public key that can later be used to tie the deposit to a issuance transaction.'),(0,a.kt)("h2",{id:"receiving-bitcoin"},"Receiving Bitcoin"),(0,a.kt)("p",null,"When depositing Bitcoin into the federation a client proceeds as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Generate public/secret key pair"),(0,a.kt)("li",{parentName:"ol"},"Tweak federation descriptor with public key"),(0,a.kt)("li",{parentName:"ol"},"Send BTC to the resulting address"),(0,a.kt)("li",{parentName:"ol"},"Generate ",(0,a.kt)("a",{parentName:"li",href:"https://bitcoincore.org/en/doc/0.21.0/rpc/blockchain/gettxoutproof/"},"TxOutProof")," and fetch raw transaction. These compact data structures allow the federation to verify the\ndeposit with only the block hashes being synced and not the whole chain."),(0,a.kt)("li",{parentName:"ol"},"The tweak together with the TxOutProof and the raw transaction can now be sent to the federation to prove money was\ndeposited. The federation should require a signature using the secret key.")),(0,a.kt)("p",null,"Note that only once the federation is in possession of the tweak they can actually spend the funds as it is also needed\nto tweak the private keys."),(0,a.kt)("h2",{id:"sending-bitcoin"},"Sending Bitcoin"),(0,a.kt)("p",null,"Once the federation agrees on paying Bitcoin to a set of destinations every participant deterministically selects\nthe necessary outputs. The previously agreed-upon fee rate is used to determine the fee. In case a change address is needed\nthe randomness beacon is used to derive a random change address just as a deposit address would be derived."),(0,a.kt)("p",null,"This transaction is then signed by each participant individually and the signatures broadcasted via the consensus\nprotocol. Note that due to the transaction being generated deterministically it does not need to be exchanged itself."),(0,a.kt)("p",null,"After receiving sufficient signatures each party can assemble the final transaction and broadcast it."))}u.isMDXComponent=!0}}]);